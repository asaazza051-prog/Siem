#!/usr/bin/env python3
import os, re, time, html, socket, hashlib, threading
from functools import lru_cache
from datetime import datetime, timezone
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor
from flask import Flask, request, jsonify
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# Optional imports
try:
    from zoneinfo import ZoneInfo
except Exception:
    ZoneInfo = None
try:
    from prometheus_client import Counter, start_http_server
except Exception:
    Counter = start_http_server = None

# --- Config (inlined keys as requested) ---
VT_API_KEY       ="<YOUR_VIRUSTOTAL_API_KEY>"
TELEGRAM_TOKEN   = "<YOUR_TELEGRAM_BOT_TOKEN>"
TELEGRAM_CHAT_ID = "<YOUR_CHAT_ID>"

HOST = socket.gethostname()
PORT = int(os.getenv("PORT", "8080"))
MIN_TG_INTERVAL = float(os.getenv("TG_MIN_INTERVAL", "2.0"))
PROM_PORT = int(os.getenv("PROM_PORT", "9090"))

# --- App & simple logging ---
app = Flask(__name__)
import logging
logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
log = logging.getLogger("siem").info

# --- HTTP session with retries ---
s = requests.Session()
s.mount("https://", HTTPAdapter(max_retries=Retry(total=3, backoff_factor=0.5,
                                                  status_forcelist=(429,500,502,503,504))))
REQUEST_TIMEOUT = 8

# --- Executor + rate-limit ---
execpool = ThreadPoolExecutor(max_workers=4)
_last = defaultdict(float)
_lock = threading.Lock()
def _key(msg): return hashlib.sha256(msg.encode()).hexdigest()[:12]

def send_telegram(msg, bg=True):
    if not (TG_TOKEN and TG_CHAT):
        log("Telegram disabled: missing token/chat")
        return
    k = _key(msg); now = time.time()
    with _lock:
        if now - _last.get(k, 0) < MIN_TG_INTERVAL:
            return
        _last[k] = now
    def _post():
        try:
            s.post(f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage",
                   json={"chat_id":TG_CHAT,"text":msg,"parse_mode":"HTML","disable_web_page_preview":True},
                   timeout=REQUEST_TIMEOUT).raise_for_status()
        except Exception as e:
            log(f"tg err: {e}")
    if bg:
        try: execpool.submit(_post)
        except: _post()
    else:
        _post()

# --- VirusTotal (cached) ---
@lru_cache(maxsize=1024)
def vt_scan(h):
    if not VT_API_KEY or not re.fullmatch(r"[A-Fa-f0-9]{32}|[A-Fa-f0-9]{64}", (h or "").strip()):
        return None
    try:
        r = s.get(f"https://www.virustotal.com/api/v3/files/{h}", headers={"x-apikey":VT_API_KEY}, timeout=REQUEST_TIMEOUT)
        r.raise_for_status()
        d = r.json().get("data") or {}
        stats = d.get("attributes", {}).get("last_analysis_stats", {})
        total = sum(stats.values()) if stats else 0
        return {"malicious": stats.get("malicious",0), "total": total, "link": f"https://www.virustotal.com/gui/file/{h}"}
    except Exception as e:
        log(f"vt err: {e}")
        return None

# --- Optional Prometheus metrics ---
if Counter and start_http_server:
    ALERT_COUNTER = Counter("siem_alerts_total","alerts",["action"])
    VT_MAL_COUNTER = Counter("siem_vt_malicious_total","vt_malicious")
    start_http_server(PROM_PORT)
else:
    ALERT_COUNTER = VT_MAL_COUNTER = None

# --- Helpers ---
def local_time_str():
    if ZoneInfo:
        try:
            return datetime.now(ZoneInfo("Asia/Ho_Chi_Minh")).strftime("%Y-%m-%d %H:%M:%S %Z")
        except Exception:
            pass
    return datetime.now(timezone.utc).astimezone().strftime("%Y-%m-%d %H:%M:%S %Z")

def safe(s): return html.escape(str(s or ""))

def extract(result):
    for k in ("syscheck.path","syscheck_path","file_path","path"):
        if v := result.get(k):
            return v, _extract_hash(result), _extract_action(result)
    raw = str(result.get("full_log") or result.get("_raw") or "")
    m = re.search(r"[Ff]ile ['\"]([^'\"]+)['\"]", raw)
    return (m.group(1) if m else "unknown"), _extract_hash(result), _extract_action(result)

def _extract_hash(result):
    for k in ("sha256","md5","syscheck.sha256_after","syscheck_sha256_after",
              "syscheck.md5_after","syscheck_md5_after","syscheck.sha256_before","syscheck_sha256_before"):
        if v := result.get(k):
            return str(v).strip()
    sc = result.get("syscheck") or {}
    return str(sc.get("sha256_after") or sc.get("md5_after") or sc.get("sha256_before") or sc.get("md5_before") or "N/A")

def _extract_action(result):
    t = (str(result.get("full_log",""))+" "+str(result.get("_raw",""))).lower()
    if "added" in t or "created" in t: return "TH√äM M·ªöI"
    if "deleted" in t: return "B·ªä X√ìA"
    if "modified" in t or "integrity checksum changed" in t: return "S·ª¨A ƒê·ªîI"
    return "THAY ƒê·ªîI"

# --- Routes ---
@app.post("/siem")
def siem():
    p = request.get_json(force=True, silent=True)
    if not p: return jsonify(error="invalid json"), 400
    res = p.get("result", p)
    path, file_hash, action = extract(res)
    if ALERT_COUNTER: ALERT_COUNTER.labels(action=action).inc()
    t = local_time_str()
    msg = (f"<b>WAZUH ‚Üí SPLUNK ‚Üí TELEGRAM</b>\n"
           f"<b>{safe(action)} FILE</b>\nFile: <code>{safe(path)}</code>\nHash: <code>{safe(file_hash)}</code>\n"
           f"Host: <code>{safe(HOST)}</code>\n‚è± Th·ªùi gian: <b>{safe(t)}</b>\n<i>SIEM</i>")
    send_telegram(msg)
    if file_hash and file_hash!="N/A":
        vt = vt_scan(file_hash)
        if vt and vt.get("malicious",0)>0:
            if VT_MAL_COUNTER: VT_MAL_COUNTER.inc()
            m2 = (f"<b>üö® PH√ÅT HI·ªÜN M√É ƒê·ªòC!</b>\nFile: <code>{safe(path)}</code>\nHash: <code>{safe(file_hash)}</code>\n"
                  f"‚ö†Ô∏è Ph√°t hi·ªán: <b>{vt['malicious']}/{vt['total']}</b>\nüîó <a href=\"{safe(vt['link'])}\">VirusTotal</a>")
            send_telegram(m2)
    return jsonify(status="ok")

@app.get("/health")
def health(): return jsonify(status="ok", hostname=HOST, vt=bool(VT_API_KEY), tg=bool(TG_TOKEN and TG_CHAT))

if __name__ == "__main__":
    log("Starting compact SIEM webhook (keys inlined)")
    app.run(host="0.0.0.0", port=PORT, threaded=True)
