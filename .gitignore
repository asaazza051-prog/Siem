#!/usr/bin/env python3
import os, re, time, html, socket, hashlib, threading
from functools import lru_cache
from datetime import datetime, timezone
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor
from flask import Flask, request, jsonify
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import logging

# Optional imports
try:
    from zoneinfo import ZoneInfo
except Exception:
    ZoneInfo = None
try:
    from prometheus_client import Counter, start_http_server
except Exception:
    Counter = start_http_server = None

# --- Config (read from env; avoid inlining secrets) ---
VT_API_KEY       = os.getenv("VT_API_KEY") or os.getenv("VIRUSTOTAL_API_KEY")
TG_TOKEN         = os.getenv("TELEGRAM_TOKEN") or os.getenv("TG_TOKEN")
TG_CHAT          = os.getenv("TELEGRAM_CHAT_ID") or os.getenv("TG_CHAT")
HOST = socket.gethostname()
PORT = int(os.getenv("PORT", "8080"))
MIN_TG_INTERVAL = float(os.getenv("TG_MIN_INTERVAL", "2.0"))
PROM_PORT = int(os.getenv("PROM_PORT", "9090"))

# --- App & logging ---
app = Flask(__name__)
logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
logger = logging.getLogger("siem")

# --- HTTP session with retries ---
s = requests.Session()
s.mount("https://", HTTPAdapter(max_retries=Retry(total=3, backoff_factor=0.5,
                                                  status_forcelist=(429,500,502,503,504))))
REQUEST_TIMEOUT = 8

# --- Executor + rate-limit ---
execpool = ThreadPoolExecutor(max_workers=int(os.getenv("MAX_WORKERS", "4")))
_last = defaultdict(float)
_lock = threading.Lock()
def _key(msg): return hashlib.sha256(msg.encode("utf-8")).hexdigest()[:12]

def send_telegram(msg, bg=True):
    if not (TG_TOKEN and TG_CHAT):
        logger.info("Telegram disabled: missing token/chat")
        return
    k = _key(msg); now = time.time()
    with _lock:
        if now - _last.get(k, 0) < MIN_TG_INTERVAL:
            return
        _last[k] = now
    def _post():
        try:
            r = s.post(f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage",
                   json={"chat_id":TG_CHAT,"text":msg,"parse_mode":"HTML","disable_web_page_preview":True},
                   timeout=REQUEST_TIMEOUT)
            r.raise_for_status()
        except Exception:
            logger.exception("tg err")
    if bg:
        try:
            execpool.submit(_post)
        except Exception:
            _post()
    else:
        _post()

@lru_cache(maxsize=1024)
def vt_scan(h):
    if not VT_API_KEY or not re.fullmatch(r"[A-Fa-f0-9]{32}|[A-Fa-f0-9]{64}", (h or "").strip()):
        return None
    try:
        r = s.get(f"https://www.virustotal.com/api/v3/files/{h}", headers={"x-apikey":VT_API_KEY}, timeout=REQUEST_TIMEOUT)
        r.raise_for_status()
        d = r.json().get("data") or {}
        stats = d.get("attributes", {}).get("last_analysis_stats", {})
        total = sum(stats.values()) if stats else 0
        return {"malicious": stats.get("malicious",0), "total": total, "link": f"https://www.virustotal.com/gui/file/{h}"}
    except Exception:
        logger.exception("vt err")
        return None

# --- Optional Prometheus metrics ---
if Counter and start_http_server:
    ALERT_COUNTER = Counter("siem_alerts_total","alerts",["action"])
    VT_MAL_COUNTER = Counter("siem_vt_malicious_total","vt_malicious")
    start_http_server(PROM_PORT)
else:
    ALERT_COUNTER = VT_MAL_COUNTER = None

def local_time_str():
    if ZoneInfo:
        try:
            return datetime.now(ZoneInfo("Asia/Ho_Chi_Minh")).strftime("%Y-%m-%d %H:%M:%S %Z")
        except Exception:
            pass
    return datetime.now(timezone.utc).astimezone().strftime("%Y-%m-%d %H:%M:%S %Z")

def safe(s): return html.escape(str(s or ""))

def extract(result):
    if not isinstance(result, dict):
        return "unknown", "N/A", "THAY ƒê·ªîI"
    for k in ("syscheck.path","syscheck_path","file_path","path"):
        if v := result.get(k):
            return v, _extract_hash(result), _extract_action(result)
    raw = str(result.get("full_log") or result.get("_raw") or "")
    m = re.search(r"[Ff]ile ['\"]([^'\"]+)['\"]", raw)
    return (m.group(1) if m else "unknown"), _extract_hash(result), _extract_action(result)

def _extract_hash(result):
    for k in ("sha256","md5","syscheck.sha256_after","syscheck_sha256_after",
              "syscheck.md5_after","syscheck_md5_after","syscheck.sha256_before","syscheck_sha256_before"):
        if v := result.get(k):
            return str(v).strip()
    sc = result.get("syscheck") or {}
    return str(sc.get("sha256_after") or sc.get("md5_after") or sc.get("sha256_before") or sc.get("md5_before") or "N/A")

def _extract_action(result):
    t = (str(result.get("full_log",""))+" "+str(result.get("_raw",""))).lower()
    if "added" in t or "created" in t: return "TH√äM M·ªöI"
    if "deleted" in t: return "B·ªä X√ìA"
    if "modified" in t or "integrity checksum changed" in t: return "S·ª¨A ƒê·ªîI"
    return "THAY ƒê·ªîI"

@app.post("/siem")
def siem():
    p = request.get_json(force=True, silent=True)
    if not p: return jsonify(error="invalid json"), 400
    res = p.get("result", p)
    path, file_hash, action = extract(res)
    if ALERT_COUNTER: ALERT_COUNTER.labels(action=action).inc()
    t = local_time_str()
    msg = (f"<b>WAZUH ‚Üí SPLUNK ‚Üí TELEGRAM</b>\n"
           f"<b>{safe(action)} FILE</b>\nFile: <code>{safe(path)}</code>\nHash: <code>{safe(file_hash)}</code>\n"
           f"Host: <code>{safe(HOST)}</code>\n‚è± Th·ªùi gian: <b>{safe(t)}</b>\n<i>SIEM</i>")
    send_telegram(msg)
    if file_hash and file_hash!="N/A":
        vt = vt_scan(file_hash)
        if vt and vt.get("malicious",0)>0:
            if VT_MAL_COUNTER: VT_MAL_COUNTER.inc()
            m2 = (f"<b>üö® PH√ÅT HI·ªÜN M√É ƒê·ªòC!</b>\nFile: <code>{safe(path)}</code>\nHash: <code>{safe(file_hash)}</code>\n"
                  f"‚ö†Ô∏è Ph√°t hi·ªán: <b>{vt['malicious']}/{vt['total']}</b>\nüîó <a href=\"{safe(vt['link'])}\">VirusTotal</a>")
            send_telegram(m2)
    return jsonify(status="ok")

@app.get("/health")
def health():
    return jsonify(status="ok", hostname=HOST, vt=bool(VT_API_KEY), tg=bool(TG_TOKEN and TG_CHAT))

if __name__ == "__main__":
    logger.info("Starting compact SIEM webhook")
    # For production use gunicorn: `gunicorn -w 4 -b 0.0.0.0:8080 siem:app`
    app.run(host="0.0.0.0", port=PORT, threaded=True)
